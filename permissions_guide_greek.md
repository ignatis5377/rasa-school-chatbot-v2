# Οδηγός Ασφάλειας και Δικαιωμάτων Χρηστών

Αυτό το έγγραφο αναλύει τεχνικά πώς υλοποιήσαμε το σύστημα ελέγχου πρόσβασης (Permissions), ώστε να διαχωρίσουμε τους εγγεγραμμένους χρήστες από τους επισκέπτες.

---

## 1. Η Φιλοσοφία της Ασφάλειας

Ο στόχος ήταν:
*   **Εγγεγραμμένοι Χρήστες (Members):** Να μπορούν να δημιουργούν διαγωνίσματα και να ανεβάζουν υλικό.
*   **Επισκέπτες (Δημόσιο):** Να μπορούν μόνο να κάνουν αναζήτηση άρθρων και να ρωτούν γενικές πληροφορίες.

Η υλοποίηση βασίζεται στα **Metadata** που στέλνει η ιστοσελίδα (WordPress) στο Chatbot κατά την έναρξη της συνομιλίας.

---

## 2. Πίνακας Δικαιωμάτων (Permissions Matrix)

Ο παρακάτω πίνακας συνοψίζει τι μπορεί να κάνει κάθε χρήστης:

| Δικαίωμα | Guest (Επισκέπτης) | Student (Μαθητής) | Teacher (Καθηγητής) | Admin (Διαχειριστής) |
| :--- | :---: | :---: | :---: | :---: |
| **Αναζήτηση Άρθρων** | ✅ ΝΑΙ | ✅ ΝΑΙ | ✅ ΝΑΙ | ✅ ΝΑΙ |
| **FAQ (Ερωτήσεις)** | ✅ ΝΑΙ | ✅ ΝΑΙ | ✅ ΝΑΙ | ✅ ΝΑΙ |
| **Δημιουργία Διαγωνίσματος** | ❌ ΟΧΙ | ✅ ΝΑΙ | ✅ ΝΑΙ | ✅ ΝΑΙ |
| **Ανέβασμα Υλικού** | ❌ ΟΧΙ | ❌ ΟΧΙ | ✅ ΝΑΙ | ✅ ΝΑΙ |

---

## 3. Αντιστοίχιση Ρόλων (WordPress -> Rasa)

Επειδή το WordPress έχει τους δικούς του ρόλους, κάναμε την εξής αντιστοίχιση στον PHP κώδικα:

*   **WordPress `Administrator`** -> Rasa `administrator`
*   **WordPress `Editor` / `Author`** -> Rasa `teacher`
*   **WordPress `Subscriber`** -> Rasa `student`
*   **Logout** -> Rasa `guest`

---

## 4. Ο Μηχανισμός Ελέγχου (`actions.py`)

Η λογική των δικαιωμάτων υλοποιήθηκε απευθείας μέσα στον κώδικα των Custom Actions (`actions/actions.py`).

Στο αρχείο `actions/actions.py`, δημιουργήσαμε μια κεντρική συνάρτηση-φρουρό που ονομάζεται `check_user_access`.

### Η Συνάρτηση `check_user_access`
Αυτή η συνάρτηση ελέγχει αν ο χρήστης είναι συνδεδεμένος.

```python
def check_user_access(tracker: Tracker) -> bool:
    """
    Ελέγχει αν ο χρήστης είναι αυθεντικοποιημένος μέσω Metadata.
    Επιστρέφει True αν επιτρέπεται, False αν όχι.
    """
    # 1. Έλεγχος στο τελευταίο μήνυμα
    metadata = tracker.latest_message.get("metadata", {})
    user_data = metadata.get("customData", {}) or metadata
    
    # Αν το 'role' είναι 'member' ή υπάρχει 'username', δώσε πρόσβαση
    if user_data.get("role") == "member" or user_data.get("username"):
        return True

    # 2. Αν δεν βρέθηκε, ψάξε στο ιστορικό (γιατί το Webchat το στέλνει μόνο στην αρχή)
    for event in reversed(tracker.events):
        # ... (κώδικας που σκανάρει το ιστορικό για metadata) ...
        if role == "member" or username:
            return True
            
    return False
```

---

## 5. Εφαρμογή στις Λειτουργίες

Εδώ φαίνεται πώς η "πόρτα ασφαλείας" εφαρμόζεται επιλεκτικά.

### Α. Δημιουργία Διαγωνίσματος (Προστατευμένο)
Όταν ο χρήστης ζητάει διαγώνισμα, τρέχει το `ActionCreateExamNew`. Η πρώτη εντολή είναι ο έλεγχος.

```python
class ActionCreateExamNew(Action):
    def run(self, dispatcher, tracker, domain):
        
        # --- ΕΛΕΓΧΟΣ ΑΣΦΑΛΕΙΑΣ ---
        if not check_user_access(tracker):
            dispatcher.utter_message(text="🚫 Αυτή η λειτουργία είναι διαθέσιμη μόνο για εγγεγραμμένους χρήστες...")
            return [] # Σταματάει εδώ και δεν κάνει τίποτα άλλο
        # -------------------------

        # ... (Αν περάσει τον έλεγχο, συνεχίζει κανονικά) ...
```

### Β. Αναζήτηση Άρθρων (Δημόσιο)
Όταν ο χρήστης κάνει αναζήτηση, τρέχει το `ActionSearchArticles`. Σε αυτή τη συνάρτηση **ΔΕΝ** βάλαμε κανέναν έλεγχο.

```python
class ActionSearchArticles(Action):
    def run(self, dispatcher, tracker, domain):
        
        # Κανένας έλεγχος εδώ! Το bot προχωράει κατευθείαν.
        
        query = tracker.get_slot("query")
        # ... (Εκτελεί την αναζήτηση κανονικά για όλους, είτε συνδεδεμένοι είτε όχι) ...
```

---

## 6. Ασφάλεια Αρχείων (FileSystem)

*   **Linux Permissions:** Δώσαμε `chmod 777` στους φακέλους `data/` και `files/` ώστε ο Docker Container (που τρέχει ως user 1001) να μπορεί να γράφει στη βάση δεδομένων και να αποθηκεύει τα PDF.
*   **Isolation:** Τα αρχεία του συστήματος (`actions.py`, `credentials.yml`) είναι Read-Only μέσα στο container, άρα κανείς δεν μπορεί να τα πειράξει μέσω του Chatbot.

---

## 7. Συμπέρασμα

Το σύστημα εφαρμόζει **Ασφάλεια σε Βάθος (Defense in Depth)**. 

Η "πόρτα ασφαλείας" βρίσκεται ακριβώς στην είσοδο της λειτουργίας δημιουργίας διαγωνίσματος (`ActionCreateExamNew`), ενώ η αναζήτηση είναι ελεύθερη από επιλογή.

Το σύστημα είναι ασφαλές επειδή ο έλεγχος γίνεται στον **Server (Backend)**. Ακόμα και αν κάποιος προσπαθήσει να ξεγελάσει το Chatbot ζητώντας επίμονα "φτιάξε μου διαγώνισμα", ο Python κώδικας στον server θα ελέγξει την ταυτότητά του και θα του απαγορεύσει την πρόσβαση αν δεν είναι μέλος.
